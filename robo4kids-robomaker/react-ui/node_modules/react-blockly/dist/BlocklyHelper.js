"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parseWorkspaceXml;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * @param {string} xml
 */
function parseWorkspaceXml(xml) {
  var arrayTags = ['name', 'custom', 'colour', 'categories', 'blocks', 'button'];
  var xmlDoc = null;

  if (window.DOMParser) {
    xmlDoc = new DOMParser().parseFromString(xml, 'text/xml');
  } else if (window.ActiveXObject) {
    xmlDoc = new ActiveXObject('Microsoft.XMLDOM');
    xmlDoc.async = false;

    if (!xmlDoc.loadXML(xml)) {
      throw new Error("".concat(xmlDoc.parseError.reason, " ").concat(xmlDoc.parseError.srcText));
    }
  } else {
    throw new Error('cannot parse xml string!');
  }

  function isArray(o) {
    return Object.prototype.toString.apply(o) === '[object Array]';
  }
  /**
   * @param {string} xmlNode
   * @param {Array.<string>} result
   */


  function parseNode(xmlNode, result) {
    if (xmlNode.nodeName === '#text') {
      var v = xmlNode.nodeValue;

      if (v.trim()) {
        result.value = v;
      }

      return;
    }

    var jsonNode = {};
    var existing = result[xmlNode.nodeName];

    if (existing) {
      if (!isArray(existing)) {
        result[xmlNode.nodeName] = [existing, jsonNode];
      } else {
        result[xmlNode.nodeName].push(jsonNode);
      }
    } else if (arrayTags && arrayTags.indexOf(xmlNode.nodeName) !== -1) {
      result[xmlNode.nodeName] = [jsonNode];
    } else {
      result[xmlNode.nodeName] = jsonNode;
    }

    if (xmlNode.attributes) {
      for (var i = 0; i < xmlNode.attributes.length; i++) {
        var attribute = xmlNode.attributes[i];
        jsonNode[attribute.nodeName] = attribute.nodeValue;
      }
    }

    for (var _i = 0; _i < xmlNode.childNodes.length; _i++) {
      parseNode(xmlNode.childNodes[_i], jsonNode);
    }
  }

  var result = {};

  if (xmlDoc.childNodes.length) {
    parseNode(xmlDoc.childNodes[0], result);
  }

  return transformed(result);
}

function transformed(result) {
  var filteredResult = [];
  var xml = result.xml;
  var categories = xml.category;

  for (var i = 0; i < categories.length; i++) {
    var c = categories[i];
    var cNew = {};
    cNew.name = c.name;
    cNew.colour = c.colour;
    cNew.custom = c.custom;
    cNew.button = c.button;

    if (c.block) {
      cNew.blocks = parseBlocks(c.block);
    }

    filteredResult.push(cNew);
  }

  return filteredResult;
}

function parseBlocks(blocks) {
  var arr = ensureArray(blocks);
  var res = [];
  arr.forEach(function (block) {
    var obj = parseObject(block);
    obj.type = block.type;
    res.push(obj);
  });
  return res;
}

function parseFields(fields) {
  var arr = ensureArray(fields);
  var res = {};
  arr.forEach(function (field) {
    res[field.name] = field.value;
  });
  return res;
}

function parseValues(values) {
  var arr = ensureArray(values);
  var res = {};
  arr.forEach(function (value) {
    res[value.name] = parseObject(value);
  });
  return res;
}

function ensureArray(obj) {
  if (obj instanceof Array) {
    return obj;
  }

  return [obj];
}

function parseObject(obj) {
  var res = {};

  if (obj.shadow) {
    res = parseObject(obj.shadow);
    res.type = obj.shadow.type;
    res.shadow = true;
  } else if (obj.block) {
    res = parseObject(obj.block);
    res.type = obj.block.type;
    res.shadow = false;
  }

  if (obj.mutation) {
    res.mutation = {
      attributes: obj.mutation,
      innerContent: obj.mutation.value
    };
  }

  if (obj.field) {
    res.fields = parseFields(obj.field);
  }

  if (obj.value) {
    res.values = parseValues(obj.value);
  }

  if (obj.next) {
    res.next = parseObject(obj.next);
  }

  if (obj.statement) {
    res.statements = _defineProperty({}, obj.statement.name, parseObject(obj.statement));
  }

  return res;
}